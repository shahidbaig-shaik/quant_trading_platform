"""
events.py — Event Class Hierarchy for the Trading Engine.

Defines the core event types that flow through the event-driven
architecture. Each event is an immutable dataclass with strict type hints.

Event Flow:
    MarketEvent → SignalEvent → OrderEvent → FillEvent
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto


# ──────────────────────────────────────────────
#  Enums for type-safe categorical fields
# ──────────────────────────────────────────────

class SignalType(Enum):
    """Direction bias produced by a strategy."""
    LONG = "LONG"
    SHORT = "SHORT"


class OrderType(Enum):
    """Supported order types."""
    MARKET = auto()
    LIMIT = auto()
    STOP = auto()


class Direction(Enum):
    """Trade direction."""
    BUY = "BUY"
    SELL = "SELL"


# ──────────────────────────────────────────────
#  Base Event
# ──────────────────────────────────────────────

@dataclass(frozen=True)
class Event:
    """
    Abstract base class for all events in the trading engine.

    Every event carries a `timestamp` that records when it was created.
    Subclasses are frozen (immutable) to guarantee safe passage through
    the event queue.
    """
    timestamp: datetime = field(default_factory=datetime.utcnow)

    @property
    def event_type(self) -> str:
        """Return the class name as a convenient type tag."""
        return self.__class__.__name__


# ──────────────────────────────────────────────
#  Concrete Events
# ──────────────────────────────────────────────

@dataclass(frozen=True)
class MarketEvent(Event):
    """
    Triggered when the DataHandler pushes a new bar (OHLCV row)
    onto the event queue.

    The MarketEvent itself carries no payload — the DataHandler
    exposes the latest bar via its own API.  This event simply
    signals that fresh data is available.
    """
    pass


@dataclass(frozen=True)
class SignalEvent(Event):
    """
    Generated by a Strategy object when it detects a trading opportunity.

    Attributes
    ----------
    symbol : str
        The ticker / instrument identifier (e.g. "AAPL").
    signal_type : SignalType
        LONG, SHORT, or EXIT.
    strength : float
        Confidence / magnitude of the signal, typically in [0.0, 1.0].
        A value of 1.0 represents maximum conviction.
    """
    symbol: str = ""
    signal_type: SignalType = SignalType.LONG
    strength: float = 1.0

    def __post_init__(self) -> None:
        if not self.symbol:
            raise ValueError("SignalEvent requires a non-empty `symbol`.")
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(
                f"Signal strength must be in [0.0, 1.0], got {self.strength}."
            )


@dataclass(frozen=True)
class OrderEvent(Event):
    """
    Generated by the Portfolio when it decides to act on a SignalEvent.

    Attributes
    ----------
    symbol : str
        The ticker / instrument identifier.
    order_type : OrderType
        MARKET, LIMIT, or STOP.
    quantity : int
        Number of shares / contracts (always positive).
    direction : Direction
        BUY or SELL.
    """
    symbol: str = ""
    order_type: OrderType = OrderType.MARKET
    quantity: int = 0
    direction: Direction = Direction.BUY

    def __post_init__(self) -> None:
        if not self.symbol:
            raise ValueError("OrderEvent requires a non-empty `symbol`.")
        if self.quantity <= 0:
            raise ValueError(
                f"Order quantity must be > 0, got {self.quantity}."
            )

    def __repr__(self) -> str:
        return (
            f"OrderEvent(symbol={self.symbol!r}, "
            f"order_type={self.order_type.name}, "
            f"qty={self.quantity}, "
            f"direction={self.direction.name})"
        )


@dataclass(frozen=True)
class FillEvent(Event):
    """
    Generated by the ExecutionHandler after an order has been filled.

    Attributes
    ----------
    symbol : str
        The ticker / instrument identifier.
    direction : Direction
        BUY or SELL (echoed from the originating OrderEvent).
    quantity : int
        Number of shares / contracts filled.
    fill_price : float
        The price at which the order was filled.
    commission : float
        Brokerage / exchange fees for this fill.
    """
    symbol: str = ""
    direction: Direction = Direction.BUY
    quantity: int = 0
    fill_price: float = 0.0
    commission: float = 0.0

    def __post_init__(self) -> None:
        if not self.symbol:
            raise ValueError("FillEvent requires a non-empty `symbol`.")
        if self.fill_price < 0:
            raise ValueError(
                f"Fill price cannot be negative, got {self.fill_price}."
            )
        if self.commission < 0:
            raise ValueError(
                f"Commission cannot be negative, got {self.commission}."
            )

    @property
    def cost(self) -> float:
        """Total cost of the fill including commission."""
        return (self.fill_price * self.quantity) + self.commission

    def __repr__(self) -> str:
        return (
            f"FillEvent(symbol={self.symbol!r}, "
            f"direction={self.direction.name}, "
            f"qty={self.quantity}, "
            f"fill_price={self.fill_price:.4f}, "
            f"commission={self.commission:.2f}, "
            f"cost={self.cost:.2f})"
        )
